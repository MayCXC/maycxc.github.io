<!DOCTYPE html>
<html style="height: 100%">
<head>
    <meta charset="UTF-8"/>
    <style>
        body {
            width: auto;
            height: auto;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>

    <script id="cube" type="x-shader/x-vertex">
        attribute vec4 vertex;
        uniform vec2 aspect;
        uniform vec3 position;
        uniform vec4 orientation;
        uniform vec3 size;

        mat4 translate(vec3 v) {
            return mat4(
                1,0,0,0,
                0,1,0,0,
                0,0,1,0,
                v,1
            );
        }

        mat4 rotate(vec4 v) {
            float scalar = v.w;
            vec3 vector  = vec3(v);

            mat3 identity = mat3(1.0);
            mat3 skew = mat3(
                cross(vector, identity[0]),
                cross(vector, identity[1]),
                cross(vector, identity[2])
            );

            mat3 outer = mat3(0.0);
            for(int i=0; i<3; i+=1) {
                for(int j=0; j<3; j+=1) {
                    outer[i][j] =  vector[j] * vector[i];
                }
            }

            return mat4(outer + mat3(scalar*scalar) + 2.0*scalar*skew + skew*skew);
        }

        mat4 rotate(float t, int a, int b) {
            mat4 rodriguez = mat4(1.0);
            for(int i=0; i<3; i+=1) {
                for(int j=0; j<3; j+=1) {
                    rodriguez[j][i] =
                        i == a || i == b || j == a || j == b ? rodriguez[j][i]:
                        i < j ? -sin(t):
                        i == j ? cos(t):
                        i > j ? sin(t):
                        0.0;
                }
            }
            return rodriguez;
        }

        mat4 scale(vec3 v) {
            return mat4(
                v.x,0,0,0,
                0,v.y,0,0,
                0,0,v.z,0,
                0,0,0,1
            );
        }

        mat4 project() {
            return mat4(
                aspect.y/length(aspect),0,0,0,
                0,aspect.x/length(aspect),0,0,
                0,0,1.0,-1.0,
                0,0,0.0,1.0
            );
        }

        void main() {
            float near = .1;
            float far = 1000.0;

            gl_Position = project() // P
            * rotate(orientation)
            * translate(position)
            * translate(vec3(0,0,0)) // M
            * rotate(vec4(0,0,0,1.0))
            * scale(size)
            * vertex;
        }
    </script>

    <script id="color" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #else
        precision mediump float;
        #endif
        uniform vec4 color;
        void main() {
            gl_FragColor = color;
        }
    </script>

    <script>
        /*
         *     2__________3
         *     /|        /|
         *    / |       / |
         *  6/__|_____7/  |
         *  |  0|______|_1|
         *  |  /       |  /
         *  | /        | /
         * 4|/________5|/
         *
         */
        function zorder(p, n) {
            var v = [];
            for(var i=0; i<n; i+=1) {
                v[i] = (p&(1<<i))==0?1:-1;
            }
            return v;
        }

        var gl, program, buffer, vertex, aspect, position, orientation, size, color, wasd, mouse;
        function start() {
            gl = document.getElementById('scene').getContext('webgl');

            var glcube = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(glcube, document.getElementById("cube").firstChild.nodeValue);
            gl.compileShader(glcube);

            var glcolor = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(glcolor, document.getElementById("color").firstChild.nodeValue);
            gl.compileShader(glcolor);

            program = gl.createProgram();
            gl.attachShader(program, glcube);
            gl.attachShader(program, glcolor);

            console.log(gl.getShaderInfoLog(glcube));
            console.log(gl.getShaderInfoLog(glcolor));

            gl.linkProgram(program);

            console.log(gl.getProgramInfoLog(program));

            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            var vertices = new Float32Array([
                -1,-1,-1, 1,-1,-1, -1,1,-1, 1,1,-1,
                1,1,1, 1,-1,-1, 1,-1,1, -1,-1,1,
                1,1,1, -1,1,1, -1,1,-1, -1,-1,1,
                -1,-1,-1
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            gl.useProgram(program);

            vertex = gl.getAttribLocation(program, 'vertex');
            gl.enableVertexAttribArray(vertex);

            aspect = gl.getUniformLocation(program, 'aspect');
            position = gl.getUniformLocation(program, 'position');
            gl.uniform3fv(position, [0.0,0.0,-100.0]);
            orientation = gl.getUniformLocation(program, 'orientation');
            gl.uniform4fv(orientation, [0.0,0.0,0.0,1.0]);
            size = gl.getUniformLocation(program, 'size');
            gl.uniform3fv(size, [100.0,100.0,100.0]);
            color = gl.getUniformLocation(program, 'color');
            gl.uniform4fv(color, [0.3,0.6,0.9,0.3]);

            wasdph = [false,false,false,false];
            var codes = ["KeyW", "KeyA", "KeyS", "KeyD", "Space", "ShiftLeft"];
            document.addEventListener('keydown', (k) => wasdph[codes.indexOf(k.code)] = true);
            document.addEventListener('keyup', (k) => wasdph[codes.indexOf(k.code)] = false);

            mouse = [0,0,0,0];
            document.addEventListener('mousemove', (m) => mouse = m.buttons == 0
                ? [m.movementX*.25 + mouse[0]*.75, m.movementY*.25 + mouse[1]*.75] : [0,0]
            );

            requestAnimationFrame(loop);
        }

        function eulerAA(v, t) {
            return [v[0]*Math.sin(t/2), v[1]*Math.sin(t/2), v[2]*Math.sin(t/2), Math.cos(t/2)];
        }

        function compose(q, p) {
            return c = [
              + q[0]*p[3] + q[1]*p[2] - q[2]*p[1] + q[3]*p[0],
              - q[0]*p[2] + q[1]*p[3] + q[2]*p[0] + q[3]*p[1],
              + q[0]*p[1] - q[1]*p[0] + q[2]*p[3] + q[3]*p[2],
              - q[0]*p[0] - q[1]*p[1] - q[2]*p[2] + q[3]*p[3]
            ];
        }

        function conjugate(q) {
            return [-q[0], -q[1], -q[2], q[3]];
        }

        function rotate(v, q) {
            return compose(compose(q, v.concat(0)), conjugate(q)).slice(0,3);
        }

        function normalize(q) {
            var l = Math.sqrt(q.map(c => c*c).reduce((l,r) => l+r));
            return q.map(c => c/l);
        }

        var step=1000/60, tick=0, delta=0;
        function loop(tock) {
            delta = Math.min(delta+tock-tick, 1000);

            gl.canvas.width = window.innerWidth;
            gl.canvas.height = window.innerHeight;
            gl.viewport(0,0, gl.canvas.width,gl.canvas.height);
            gl.uniform2fv(aspect, [gl.canvas.width,gl.canvas.height]);

            var look = gl.getUniform(program, orientation);
            var turn = [look,
                eulerAA(rotate([1,0,0], conjugate(look)), mouse[1]/64),
                eulerAA(rotate([0,1,0], conjugate(look)), mouse[0]/64)
            ].reduce(compose);
            gl.uniform4fv(orientation, turn);

            mouse = [0,0];

            var move = gl.getUniform(program, position);
            var walk = rotate([
                (wasdph[1]?10:0) - (wasdph[3]?10:0),
                (wasdph[5]?10:0) - (wasdph[4]?10:0),
                (wasdph[0]?10:0) - (wasdph[2]?10:0)
            ], conjugate(turn));
            gl.uniform3fv(position, [0,1,2].map(i => move[i]+walk[i]));

            while(delta>=step) {
                draw();
                delta -= step;
            }
            requestAnimationFrame(loop);
            tick = tock;
        }

        var t = 0.0;
        function draw() {
            gl.clearColor(0,0,0,1);
            gl.clearDepth(1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(
                vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(vertex);
            gl.useProgram(program);
            gl.drawArrays(gl.LINE_STRIP, 0, 13);
            t += 1;
        }
    </script>
</head>
<body onload="start();">
    <canvas id="scene"></canvas>
</body>
</html>
